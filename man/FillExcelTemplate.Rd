% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FillExcelTemplate.R
\name{FillExcelTemplate}
\alias{FillExcelTemplate}
\title{Funktion befuellt ein Excel Template.}
\usage{
FillExcelTemplate(tab1, tab2 = NULL, startingPoints, nrEmptyRows,
  inheritTemplateColNr = 1, customColNr = NULL, customCol = NULL,
  footnote = NULL, f_in, sheet = 1, prefixTSN = "_",
  removeTemplateSheet = FALSE, removeAllTemplates = FALSE,
  interactive = TRUE, showFinalTab = FALSE, showSplitTab = FALSE)
}
\arguments{
\item{tab1}{eine mit \code{MakeTable()} bzw.
\code{MakeAKETimeInstantsTable()} erzeugte Tabelle. Falls bei
\code{MakeTable()} limits angegeben und einzelne Zellen mit Klammern oder
Aehnlichem belegt wurden muss auch tab2 angegeben werden damit man die Werte
in den Zellen bekommt.}

\item{tab2}{NULL oder eine mit \code{MakeTable()} bzw.
\code{MakeAKETimeInstantsTable()} erzeugte Tabelle bei der limits NICHT
angegeben wurden. Diese Tabelle muss immer uebergeben werden wenn fuer die
Erstellung von tab1 limits beruecksichtigt wurden.}

\item{startingPoints}{numerischer Vektor: die Startzeilen der befuellten
Zeilen nach Leerzeilen im Original-Excel-File.}

\item{nrEmptyRows}{numerischer Vektor: Anzahl an Leerzeilen die vor
\code{startingPoints} kommen sollen; eigentlich immer 1 ausser vor grossen
Bloecken.}

\item{inheritTemplateColNr}{numerischer Vektor: Spaltennummer/n der Tabellenspalten die vom Original-Excel-File uebernommen werden sollen.
Default ist die erste Spalte, also \code{inheritTemplateColNr=1}.}

\item{customColNr}{numerischer Wert: Spaltennummer der Tabellenspalte die ueber \code{customCol} individuell definiert werden soll (derzeit nur EINE moeglich).}

\item{customCol}{character Vektor: enthaelt die Eintraege der durch \code{customColNr} definierten Tabellenspalte - falls diese 
nicht aus dem Original-Excel-File uebernommen werden sollen und auch nicht durch \code{MakeTable()} generiert werden. 
Derzeit (kein Bedarf) wird hier ein Character Vektor OHNE Missings uebergeben, die ueber \code{startingPoints} 
und \code{nrEmptyRows} definierten Leerzeilen werden also einfach uebernommen.}

\item{footnote}{character: Fussnote (derzeit fix 1-te Zelle der 2-ten Zeile nach Tabellenende), falls sie nicht aus dem Original-Excel-File ubernommen werden soll.
Formatierung der Zelle der die Fussnote zugewiesen wird bleibt allerdings wie im Original-Excel-File.}

\item{f_in}{File Name inklusive Pfad und File-Endungen des eingelesenen
Original-Excel-Files.}

\item{sheet}{Index oder Name des Excel-Sheets oder des zugehoerigen Template-Excel-Sheets.}

\item{prefixTSN}{Character: das Prefix des Namens des Template Sheets (siehe Details). 
Default ist "_".}

\item{removeTemplateSheet}{TRUE/FALSE ob das Template-Excel-Sheet (mit dem Prefix \code{prefixTSN}) zum aktuell 
bearbeiteten Excel-Sheet geloescht werden soll, also ob es nicht im ausgelesenen File enthalten sein soll.}

\item{removeAllTemplates}{TRUE/FALSE wie bei \code{removeTemplateSheet}, nur dass hier abgefragt wird, 
ob ALLE Template-Excel-Sheets, also alle Sheets mit dem Prefix \code{prefixTSN},
geloescht werden sollen, also ob das ausgelesene File keine Templates mehr enthalten soll.}

\item{interactive}{Logical ob das Loeschen von Template-Sheets (\code{removeTemplateSheet},\code{removeAllTemplates}) 
erst manuell durch den Nutzer bestaetigt werden soll.}

\item{showFinalTab}{Logical: Falls TRUE, wird in R die Tabelle samt Leerzeilen ausgegeben wie 
sie auch im ausgelesenen Excel-File landen wuerde. Ist dieser Parameter gesetzt, wird also kein Excel-File erstellt.}

\item{showSplitTab}{Logical: Falls TRUE, wird in R die durch \code{startingPoints} aufgesplittete Tabelle ausgegeben. 
Ist dieser Parameter gesetzt, wird also kein Excel-File erstellt.}
}
\value{
Output ist ein Excel-File.
}
\description{
Funktion liest ein Excel-File ein, uebernimmt die Formatvorlage eines ausgewaehlten 
Template-Excel-Sheets, befuellt die Kopie dieses Template-Excel-Sheets mit den Ergebnissen aus \link{MakeTable} und liest 
das Ergebnis samt urspruenglichem Template-Excel-Sheet (default) und dem neu befuellten Excel-Sheet wieder als
Excel-File aus.
}
\details{
Ein Template-Excel-Sheet, das als Vorlage fuer das zu befuellende Excel-Sheet dient 
und i.d.R. leer ist bis auf einige Formate, Header und Rownames, wird durch ein Prefix im Sheet-Namen 
gekennzeichnet (\code{prefixTSN}). Der Sheet-Name ist bis auf das Prefix identisch
zum Sheet-Namen des zu befuellenden neuen Excel-Sheets. Sollte entweder Template oder 
zu befuellendes neues Excel-Sheet noch nicht existieren, wird es automatisch 
angelegt. Die Template-Sheets koennen bei Bedarf wieder einzeln (\code{removeTemplateSheet}) 
oder alle auf einmal (removeAllTemplates) geloescht werden. Sollten sowohl das Template 
als auch das neue Sheet im File schon existieren ist es irrelevant ob bei \code{sheet} 
das Template oder das neue Sheet angegeben wird.

Derzeit funktioniert diese Funktion nur fuer die Default-Werte von
\code{markLeft1}, \code{markRight1}, \code{markValue1}, \code{markLeft2},
\code{markRight2} und \code{markValue2} aus \code{MakeTable()} und
\code{MakeAKETimeInstantsTable()}.
}
\examples{
\dontrun{
###
Kommt wahrscheinlich ins mitgelieferte Bsp-File - samt Excel-Rohling.
###
}

}
\seealso{
\code{\link{MakeTable},\link{MakeAKETimeInstantsTable},\link{ImportData},\link{IndivImportData}}
}

