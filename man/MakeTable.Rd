% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MakeTable.R
\name{MakeTable}
\alias{MakeTable}
\title{Funktion zur Erstellung von Tabellen in Matrix-Form.}
\usage{
MakeTable(dat, col, row = NULL, block = NULL, estimator = "est",
  error = "cv", lim1 = Inf, markLeft1 = "(", markRight1 = ")",
  markValue1 = NULL, lim2 = Inf, markLeft2 = "(", markRight2 = ")",
  markValue2 = "x", rowPriority = TRUE, returnCommands = FALSE)
}
\arguments{
\item{dat}{MZ Daten - Output von Funktion \link{ImportData}.}

\item{col}{Listenobjekt um Spalten zu definieren, siehe Details.}

\item{row}{Listenobjekt oder NULL um Zeilen zu definieren, siehe Details.}

\item{block}{Listenobjekt oder NULL um Block-Output definieren, siehe
Details.}

\item{estimator}{character um festzulegen, welcher Schaetzer in die Tabelle
kommen soll. Auwahlmoeglichkeiten sind \code{"est"}, \code{"estPrev"},
\code{"absChange"} und \code{"relChange"}.}

\item{error}{character um festzulegen, welcher Genauigkeitsschaetzer zur Markierung von Zellen verwendet werden soll. 
Auswahlmoeglichkeiten sind \code{"cv"} (Variationskoeffizient) und \code{"ci"} (Konfidenzintervall). 
Sollte \code{error="cv"} gewaehlt werden, so sind die Parameter \code{lim1} bzw. \code{lim2} gegebenenfalls zu spezifizieren. 
Falls jedoch \code{error="ci"} gewaehlt wird, so sind diese Limits nicht notwendig, da in diesem Fall untersucht wird, 
ob der Schaetzer nicht-signifikant ist, ob also das jeweilige Konfidenzintervall den Wert 0 enthaelt. 
Man kann jedoch \code{markLeft1}, \code{markRight1} und \code{markValue1}
spezifizieren, falls die nicht-signifikanten Zellen anders als durch die Defaulteinstellung 
\code{markLeft1 = "("}, \code{markRight1 = ")"} und \code{markValue1 = NULL} markiert werden sollen.}

\item{lim1}{numerischer Wert: falls \code{lim1}>\code{error}, wird der
entsprechende Wert von \code{estimator} in der Tabelle durch
\code{markLeft1}, \code{markValue1} und \code{markRight1} ersetzt. Ist nur relevant falls code{error="cv"}.}

\item{markLeft1}{character: wird links zu \code{markValue1} hinzugefuegt.}

\item{markRight1}{character: wird rechts zu \code{markValue1} hinzugefuegt.}

\item{markValue1}{character oder NULL: falls NULL, wird der jeweilige Wert
von \code{estimator} nicht ueberschrieben.}

\item{lim2}{numerischer Wert: falls \code{lim2}>\code{error}, wird der
entsprechende Wert von \code{estimator} in der Tabelle durch
\code{markLeft2}, \code{markValue2} und \code{markRight2} ersetzt. Ist nur relevant falls code{error="cv"}.}

\item{markLeft2}{character: wird links zu \code{markValue2} hinzugefuegt. Ist nur relevant falls code{error="cv"}.}

\item{markRight2}{character: wird rechts zu \code{markValue2} hinzugefuegt. Ist nur relevant falls code{error="cv"}.}

\item{markValue2}{character oder NULL: falls NULL, wird der jeweilige Wert
von \code{estimator} nicht ueberschrieben. Ist nur relevant falls code{error="cv"}.}

\item{rowPriority}{TRUE/FALSE ob bei der Berechnung von Raten die Zeilenlogik vor der Spaltenlogik gelten soll.}

\item{returnCommands}{TRUE/FALSE ob statt einer Tabelle die Befehle
ausgegeben werden sollen die zur Erstellung der Tabelle ausgefuehrt werden
wuerden.}
}
\value{
Output ist eine Tabelle in Matrix-Form mit durch \code{col},
\code{row} und \code{block} definierten Spalten und Zeilen.
}
\description{
Erstellt eine Tabelle in Matrix-Form.
}
\details{
\strong{col}

Die Syntax fuer Spalten, Zeilen und Block Listen \code{col} ist eine aus
Sublisten bestehende Liste. Jede Subliste steht fuer eine eigene Spalte der
zu erstellenden Tabelle in Matrix-Form und gibt an, was fuer die
entsprechende Spalte berechnet werden soll. Jede Subliste kann die Argumente
\code{fun}, \code{TFstring}, \code{TFstring2}, \code{digits}, \code{var} und
\code{scaleF} enthalten. \code{fun} muss dabei gesetzt werden und zwar auf
eine der vier Funktionen \code{GroupSize}, \code{GroupRate}, \code{Mean} und
\code{Total} aus dem mzR-Paket, die restlichen Parameter sind optional.
\code{TFstring}, \code{TFstring2}, \code{digits} und \code{var} sind einfach
die Parameter aus eben genannten Funktionen, \code{scaleF} ist der
Skalierungsfaktor der auf die jeweilige Spalte angewendet werden soll, also
z.B. \code{scaleF="/1000"} gibt an, dass die Ergebnisse der entsprechenden
Spalte durch 1000 dividiert werden sollen, er ist als character zu
uebergeben.

\strong{row}

\code{row} ist eine 'list', 'named list' oder 'partly named list' die
Sublisten enthalten kann aber nicht muss. Sublisten werden eigentlich nur
uebergeben, wenn einem Element aus \code{row} mehr als ein Parameter
zugewiesen werden soll. Zusaetzlich zu den moeglichen Argumenten fuer
\code{col} (ausser \code{digits}) kann hier auch noch \code{each} gesetzt
werden (auch ein Parameter aus den mzR-Schaetz-und
Fehlerrechnungsfunktionen), \code{fun} ist hier prinzipiell optional, muss 
aber in vielen Faellen fuer einen sinnvollen Output angegeben werden. 
Will man beispielsweise einen Mittelwert berechnen, so wuerde das dementsprechende 
\code{row} Sublistenelement z.B. folgendermassen aussehen: 
\code{list(fun="Mean",var="VarName",TFstring="!is.na(VarName)",scaleF="*1")},
d.h. es wird in der entsprechenden Zeile der Tabelle jeweils der Mittelwert
der Variable VarName berechnet, zusaetzlich dazu werden aber ueber den \code{TFstring} 
auch noch die fehlenden Werte in der Variable VarName ausgeschlossen.
Wird der Parameter
\code{scaleF} bei \code{row} gesetzt, so hat er den Vorzug vor \code{scaleF}
bei \code{col} - sollte er dort gesetzt worden sein (hier nicht vergessen,
falls in \code{row} Raten berechnet werden sollen \code{scaleF="*1"}
setzen). Falls \code{GroupRate}, \code{Mean} oder \code{Total} sowohl in 
\code{row} als auch \code{col} gesetzt wurden wird fuer die jeweilige Zelle 
im Output kein Ergebnis ausgegeben.

\strong{block}

\code{block} ist eine Liste, die gewisse Einschraenkungen (oder \code{NULL},
falls keine Einschraenkung gemacht werden soll) enthaelt, welche jeweils
fuer alle Zeilen ausgefuehrt werden sollen. Diese Einschraenkungen werden
pro \code{block}-Element fuer alle \code{row}-Elemente ausgefuehrt. D.h. es
kann z.B. eine Output-Tabelle erstellt werden die im ersten 'Block' die
Ergebnisse fuer Schnecken und im zweiten Block die Ergebnisse fuer
Nicht-Schnecken enthaelt.

Kleine Bemerkung am Rande: Fuer die meisten Publikationen ist es sinnvoll, 
keine \code{digits} bei \code{col} bei \code{MakeTable()} zu setzen da oft die vorgegebenen
Excel-Formate das Runden uebernehmen.
}
\examples{
\dontrun{dat <- ImportData(year=2014,quarter=4,comp_diff_lag = 1)
### Spalten definieren
col <- list()
col[[length(col)+1]] <- list(fun="GroupSize",TFstring="balt>=15&balt<=74",
                            digits=3, scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupSize",TFstring="balt>=15&balt<=25",
                            digits=3, scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupRate",TFstring="balt>=15&balt<=25", 
                            TFstring2="balt>=15&balt<=74", digits=3)
col[[length(col)+1]] <- list(fun="GroupRate",
                            TFstring="xerwstat==1&balt>=15&balt<=74", 
                            TFstring2="xerwstat\%in\%c(1,2)&balt>=15&balt<=74", digits=3)
col[[length(col)+1]] <- list(fun="Total",
                            TFstring="xerwstat==1&balt>=15&balt<=74",var="dtstd",
                            digits=3, scaleF="/24/365")
### Zeilen definieren
row <- list(
 NULL,
 each="xnuts2",
 list(TFstring="bpras!=1 & balt>=15 & balt<=64", scaleF="*1"),
 each="rbpkin+xbstaat",
 TFstring="balt>=15&balt<=25"
)

### Bloecke definieren
block <- list(NULL, "bsex==1", "bsex==2")

### Erstellen 3 Tabellen fuer FillExcelTemplate(), jeweils mit verschiedenen Regeln 
##  zur Kennzeichnung von bestimmten Werten
##  Achtung: kann durchaus laenger dauern!

### 1. Tabelle mit Limits (bezogen auf Variationskoeffizient)
tab1 <- MakeTable(dat, col=col, row=row, block=block, error="cv", 
                 lim1=0.17, lim2=0.25)
### 2. Tabelle ohne Limits und Default-Error-Einstellung liefert unmarkierte Zellen-Werte
tab2 <- MakeTable(dat, col=col, row=row, block=block) 

### 3. Tabelle der relativen Veraenderungen vom 3. Quartal 2014 aufs 4. Quartal 2014 
##  Nicht-signifikante Schaetzwerte (Konfidenzintervall enthaelt den Wert 0) 
##  werden durch * markiert.
##  Achtung: bei einigen col-Listenelementen wurde scaleF spezifiziert. 
##  Das macht hier fuer Veraenderungen keinen Sinn, wird aber der Einfachheit halber 
##  fuer dieses Beispiel so belassen.
tab3 <- MakeTable(dat, col=col, row=row, block=block, estimator="relChange", error="ci",
                 markLeft1="",markRight1="*",markValue1=NULL) 


### Commands ansehen fuer tab1
tab1_commands <- MakeTable(dat,col=col,row=row, block=block,error="cv", 
  lim1=0.17,lim2=0.25,returnCommands=TRUE)
## -> Bsp: block 1, col 3, row 4: 
tab1_commands[[1]][[3]][[4]]

}

}
\seealso{
\code{\link{FillExcelTemplate},\link{MakeAKETimeInstantsTable},\link{ImportData},\link{IndivImportData}}
}

