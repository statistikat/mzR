% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MakeAKETimeInstantsTable.R
\name{MakeAKETimeInstantsTable}
\alias{MakeAKETimeInstantsTable}
\title{Sehr spezifische Funktion zur Erstellung von Tabellen im
MZ-Quartalsbericht-Format basierend auf MZ-Quartalsdaten die automatisch eingelesen werden.}
\usage{
MakeAKETimeInstantsTable(
  col,
  row = NULL,
  timeInstant,
  nbw = NULL,
  lim1 = Inf,
  markLeft1 = "(",
  markRight1 = ")",
  markValue1 = NULL,
  lim2 = Inf,
  markLeft2 = "(",
  markRight2 = ")",
  markValue2 = "x"
)
}
\arguments{
\item{col}{Listenobjekt um Spalten zu definieren, siehe Details.}

\item{row}{Listenobjekt oder NULL um Zeilen zu definieren, siehe Details.}

\item{timeInstant}{numerischer Vektor mit 2 Elementen: c(jahr, quartal).
Hier gibt man den Zeitpunkt an auf den sich alle Ergebnisse im weitesten
Sinn beziehen sollen, also i.d.R. das aktuellste Quartal.}

\item{nbw}{numerischer Wert: Anzahl an Bootstrap-Gewichten die eingelesen
werden soll (z.B. um Rechenzeit beim Aufsetzen der Tabellen zu verkuerzen).}

\item{lim1}{numerischer Wert: falls \code{lim1}>\code{error}, wird der
entsprechende Wert von \code{estimator} in der Tabelle durch
\code{markLeft1}, \code{markValue1} und \code{markRight1} ersetzt.}

\item{markLeft1}{character: wird links zu \code{markValue1} hinzugefuegt.}

\item{markRight1}{character: wird rechts zu \code{markValue1} hinzugefuegt.}

\item{markValue1}{character oder NULL: falls NULL, wird der jeweilige Wert
von \code{estimator} nicht ueberschrieben.}

\item{lim2}{numerischer Wert: falls \code{lim2}>\code{error}, wird der
entsprechende Wert von \code{estimator} in der Tabelle durch
\code{markLeft2}, \code{markValue2} und \code{markRight2} ersetzt.}

\item{markLeft2}{character: wird links zu \code{markValue2} hinzugefuegt.}

\item{markRight2}{character: wird rechts zu \code{markValue2} hinzugefuegt.}

\item{markValue2}{character oder NULL: falls NULL, wird der jeweilige Wert
von \code{estimator} nicht ueberschrieben.}
}
\value{
Output ist eine Tabelle in Matrix-Form nach demselben System wie die
meisten Tabellen im MZ-Quartalsbericht - mit durch \code{col} und \code{row}
definierten Spalten und Zeilen fuer bestimmte Zeitpunkte und Veraenderungen.
}
\description{
Funktion erstellt Tabellen in einem Format das im
Mikrozensus-Quartalsbericht ueblich ist. Die zugehoerigen MZ-Daten werden
dabei automatisch dem STAT-Filemanagement entsprechend eingelesen, d.h. diese
Funktion funktioniert nur STAT-intern
}
\details{
\code{col} ist eine aus Sublisten bestehende Liste. Jede Subliste steht fuer
eine eigene Spalte der zu erstellenden Tabelle in Matrix-Form und gibt an,
was fuer die entsprechende Spalte berechnet werden soll. Jede Subliste kann
die Argumente \code{fun}, \code{TFstring}, \code{TFstring2}, \code{digits},
\code{var} und \code{scaleF} enthalten. \code{fun} muss dabei gesetzt werden
und zwar auf eine der vier Funktionen \code{GroupSize}, \code{GroupRate},
\code{Mean} und \code{Total} aus dem mzR-Paket, die restlichen Parameter
sind optional. \code{TFstring}, \code{TFstring2}, \code{digits} und
\code{var} sind einfach die Parameter aus eben genannten Funktionen,
\code{scaleF} ist der Skalierungsfaktor der auf die jeweilige Spalte
angewendet werden soll, also z.B. \code{scaleF="/1000"} gibt an, dass die
Ergebnisse der entsprechenden Spalte durch 1000 dividiert werden sollen, er
ist als character zu uebergeben.

\code{row} ist eine 'list', 'named list' oder 'partly named list' die
Sublisten enthalten kann aber nicht muss. Sublisten werden eigentlich nur
uebergeben wenn einem Element aus \code{row} mehr als ein Parameter
zugewiesen werden soll. Zusaetzlich zu den moeglichen Argumenten fuer
\code{col} (ausser \code{digits}) kann hier auch noch \code{each} gesetzt
werden (auch ein Parameter aus den mzR-Schaetz-und
Fehlerrechnungsfunktionen), \code{fun} ist hier optional. Wird der Parameter
\code{scaleF} bei \code{row} gesetzt, so hat er den Vorzug vor \code{scaleF}
bei \code{col} - sollte er dort gesetzt worden sein (hier nicht vergessen,
falls in \code{row} Raten berechnet werden sollen \code{scaleF="*1"}
setzen). Dasselbe gilt weitgehend auch fuer \code{fun}, solange es Sinn
macht - hier kann es zu Faellen kommen wo kein Ergebnis ausgegeben werden
kann.

Info: \code{returnCommands} wie in \code{MakeTable()} ist hier (noch) nicht
implementiert, da diese Funktion eigentlich nur als Beispiel dienen
sollte... Kann aber bei Bedarf gemacht werden.
}
\examples{
\dontrun{
### Spalten
col <- list()
col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat!=4", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat!=4 & balt>=15", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat!=4 & balt>=15 & balt<=64", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat\%in\%c(1,2) & balt>=15", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat\%in\%c(1,2) & balt>=15 & balt<=64", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupRate",
  TFstring="xerwstat\%in\%c(1,2) & balt>=15 & balt<=64",
  TFstring2="xerwstat!=4 & balt>=15 & balt<=64")

col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat==1 & balt>=15", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat==1 & balt>=15 & balt<=64", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupRate",
  TFstring="xerwstat==1 & balt>=15 & balt<=64",
  TFstring2="xerwstat!=4 & balt>=15 & balt<=64")

col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat==2 & balt>=15", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupRate",
  TFstring="xerwstat==2 & balt>=15",
  TFstring2="xerwstat\%in\%c(1,2) & balt>=15 & balt<=74")

col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat==3 & balt>=15", scaleF="/1000")
col[[length(col)+1]] <- list(fun="GroupSize",
  TFstring="xerwstat==3 & balt>=15 & balt<=64", scaleF="/1000")

### Zeilen
row <- list(NULL,each="bsex")  

### Erstellen 2 Tabellen fuer FillExcelTemplate();
### einmal mit und einmal ohne Limits 
# Tabelle 1: Mit Limits
tab1 <- MakeTimeInstantsTable(col=col,row=row,timeInstant=c(2014,4),
  nbw=5, lim1=0.17,lim2=0.25)
# Tabelle 2: Ohne Limits
tab2 <- MakeTimeInstantsTable(col=col,row=row,timeInstant=c(2014,4),nbw=5)
}

}
\seealso{
\code{\link{MakeTable},\link{FillExcelTemplate},\link{ImportData},\link{IndivImportData}}
}
